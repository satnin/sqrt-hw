library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity sqrt_seq is
    generic (
        nb_bits : integer := 32
    );
    port (
        clk      : in  std_logic;                        -- Horloge
        reset    : in  std_logic;                        -- Réinitialisation active à '1'
        debut    : in  std_logic;                        -- Signal de démarrage
        A        : in  std_logic_vector(nb_bits-1 downto 0);  -- Entrée (valeur dont on calcule la racine)
        Resultat : out std_logic_vector((nb_bits/2)-1 downto 0); -- Sortie (racine carrée)
        fini     : out std_logic                         -- Signal de fin
    );
end entity sqrt_seq;

/* architecture archi1 of sqrt_seq is 
	type TState is (IDLE, COMPUTE, DONE);
    signal state       	: TState := IDLE;
    signal f_state       : TState := IDLE;
begin
	process(clk, reset)
	begin
		if(reset='1') then
			state <= IDLE;
		else
			if rising_edge(clk) then
				state <= f_state;	
			end if;
		end if;
	end process ; -- state
	
	process(state)
	begin
		case state is
			when IDLE =>	

			when COMPUTE =>
			   
			when DONE =>

			when others =>
			   f_state <= IDLE;
		end case;
	end process;
	
	process(state)
	begin
		case state is
			when IDLE =>	

			when COMPUTE =>
			   
			when DONE =>

			when others =>
		end case;
	end process;
end architecture; */

architecture archi1 of sqrt_seq is 
	type TState is (IDLE, COMPUTE, DONE);
    signal state       	: TState := IDLE;
    signal f_state       : TState := IDLE;
	
	signal reg_A	: std_logic_vector(nb_bits-1 downto 0);
	signal reg_R	: std_logic_vector(nb_bits-1 downto 0)
	signal reg_R_prev	: std_logic_vector(nb_bits-1 downto 0)
begin
	process(clk, reset)
	begin
		if(reset='1') then
			state <= IDLE;
		else
			if rising_edge(clk) then
				state <= f_state;
				reg_A <= reg_A;
				case state is
					when IDLE =>
						reg_A <= A;
				end case;
			end if;
		end if;
	end process ; -- state
	
	process(state, )
	begin
		case state is
			when IDLE =>	
				if debut='1' then
					f_state <= COMPUTE;
				else
					f_state <= IDLE;
				end if;
			when COMPUTE =>
				if unsigned(reg_R) == unsigned(reg_R_prev) then
					f_state <= DONE;
				else
					f_state <= COMPUTE;
				end if;
			when DONE =>
			
			when others =>
			   f_state <= IDLE;
		end case;
	end process;
	
	process(state)
	begin
		case state is
			when IDLE =>	
				reg_R <= '0'&reg_A(nb_bits-1 downto 1);
				reg_R_prev <= reg_A;
				fini <= '0';

			when COMPUTE =>
				reg_R_prev <= reg_R;
				reg_R <= std_logic_vector((unsigned(reg_R)+unsigned(reg_A)/unsigned(reg_R))*to_unsigned(2, nb_bits));
				fini <= '0';
			when DONE =>
				Resultat <= reg_R((nb_bits/2)-1 downto 0);
				fini <= '1';
			when others =>
		end case;
	end process;
end architecture;


architecture archi2 of sqrt_seq is 
begin
end architecture;

architecture archi3 of sqrt_seq is 
begin
end architecture;

architecture archi4 of sqrt_seq is 
begin
end architecture;

architecture archi5 of sqrt_seq is 
begin
end architecture;